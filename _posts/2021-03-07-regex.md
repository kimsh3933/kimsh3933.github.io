---
date: 2021-03-07
title: "Regular Expression"
categories: Informatique
---

# Regular Expression

## Intro

작업을 할 때 특정 데이터를 처리하고 찾아야 할 때가 있습니다. 예를 들자면 로그인 페이지를 작성하려고 할 때 이메일 아이디를 요구하는 경우 어떻게 처리를 할까요?

단순히 String을 가지고 작업을 하려면 @앞뒤로 문자가 있고 @가 들어가있는 것을 알면 될겁니다. 하지만 @앞뒤로 허용되지 않는 문자가 있을 수 있으며, 이를 처리하기 위해서 string 기능 만으로 처리하기에는 코드들이 복잡해집니다. 

그리고 데이터에서 이메일을 찾기 위해서 @만을 입력했지만 '선물@>---' 같은 문자가 있다면 이건 어떻게 처리해야 할까요?

찾기기능이나 검출 기능에 아래와 같은 식을 활용하면 금방 찾을 수 있습니다. 그리고 코드도 간결해 집니다.

```^(\w([\w.])*)*(\w)@(\w([\w.])*)*(\w).\w+$```

이런 모양을 가진 식을 Regular Expression 혹은 RegEx라고 합니다. 특정 형식에 맞는 문자열을 찾아야 할때 Regular Expression이 사용 됩니다.

그리고 intelliJ, 안드로이드 스튜디오, xCode같은 IDE를 사용하다 보면 특정 변수를 찾아야 할 때가 있습니다. 

예를들어

```kotlin
data class Rabbit (val id: Int, val name: String, var age: Int, val type: RabbitType)
```

라는 클래스를 정의했다고 했을 때 

```kotlin
puru = Rabbit(1, "PURU", 1, RabbitType.CREAM)
beko = Rabbit(2, "BEKO", 2, RabbitType.DWARF)
lovey = Rabbit(3, "LOVEY", 3, RabbitType.LOPEAR)
```

위와 같이 세 개의 객체를 만들어 봅시다.

다른 파일에서 작업하다가 Rabbit 클래스로 만든 객체를 찾아 봐야 하는데요, 요즘은 워낙에 IDE가 잘되어 있어서 Rabbit 클래스를 임의로 만들던지 Rabbit클래스로 가서 command+Click을 하면 어디에서 쓰는지 나오며 거기서 Rabbit 객체 생성하는 곳을 찾으면 되긴 하겠지만, Rabbit클래스를 상속받는 곳도 있을테고 의도와는 달리 항목들이 많을 수 있습니다. 생성한 객체만을 딱 보기 위해서는 어떻게 해야 할까요? 이럴 때 Regular Expression이 필요 합니다.

```
[\w]+=(Rabbit)\(\d\,\".*\",\d,RabbitType\.[\w]+\)
```

위 regex식을 가지고 검색을 하게 되면 Rabbit 객체를 어디서 생성하는지 객체 이름은 뭔지 한번에 깔끔하게 확인 가능합니다.(공백 처리는 생략하였습니다)

이처럼 특정 규칙을 가진 텍스트를 정확하고 빠르게 판별하기 위해 RegEx가 필요합니다. 특정 텍스트를 처리하거나 찾아야 할 때 불편함을 느끼셨다면 RegEx가 큰 도움이 될 것입니다. 

## Regular Expression(RegEx)는 무엇인가

- 특정한 규칙을 가진 문자열의 집합을 표현하는 형식 언어.

- IDE나 text Editor에세 문자열 검색, 치환을 위한 용도로 사용하고 있음.

- 패턴을 이용하여 패턴에 맞는 문자열을 찾을 수 있기 때문에 패턴에 맞는 문자열을 판별하는데 사용되기도 함 
  - 이메일 형식, 비밀번호 형식, 주민등록번호, 카드 번호 등등 ...
    - 주요 패턴 사용법은 아래에 서술
  - IDE나 컴파일러에서 프로그래밍 언어의 문법이 맞는지 체크하기 위해서 사용
    - 학교 다닐 때 "오토마타", "컴파일러" 같은 과목을 들었을 때 RegEx를 써본 적이 있을 것임
    - RegEx를 사용하여 규칙에 맞으면 컴파일 진행, 안맞으면 에러



이메일, 주민번호, 비밀번호 형식 등 특정 형식의 문자열을 검출하거나 찾거나 바꾸는데 사용됩니다. 그리고 우리가 사용하는 프로그래밍 언어 또한 특정 규칙을 가진 문자열이므로 이를 처리하는데 사용이 됩니다.

## Regular Expression 사용법

### 연습하고 싶다면?

Regular Expression 사용법을 알기 전에 사용해볼 수 있는 곳을 알려드리려고 합니다.

https://regex101.com 에서 작성한 Regular Expression을 시험해볼 수 있습니다. 괄호나 반복은 색으로 구분해주며 그룹 된 것도 우측에 표시를 해 줍니다. 그리고 Regex에 대한 quick reference또한 제공해 줍니다.

각 IDE에서도 Regex로 검색할 수 있는 기능을 제공합니다. 예를 들면 intelliJ/Android Studio같은 경우 검색할 때 우측에 Regex버튼을 클릭하면 Regex로 검색이 가능합니다.




### 제일 단순하게

우선은 텍스트를 찾는 것이기 때문에 특정 텍스트를 입력하기만 하면 찾을 수 있습니다.

```
My name is John. My Telephone Number:123-1234
```

해당 텍스트에서 phone만 찾고 싶다면 phone을 입력해봅니다.

> phone -> My name is John. My Tele**phone** Number:123-1234



my를 입력해봅니다.

> my -> My name is John. My Telephone Number:123-1234

아무런 응답이 없는데요, Regex는 기본적으로 대소문자를 구분을 합니다. 그렇기 때문에 우선은 대문자로 다시 검색을 합니다.

> My -> **My** name is John. **My** Telephone Number:123-1234

대문자로 검색을 하니 검색이 완료됩니다.

Regex의 경우 regex의 속성을 추가하는 flag가 있는데요, flag는 사용하는 언어에 따라서 달라집니다. 위 결과 처럼 여러개 텍스트가 리턴 되는 것은 /g flag 입니다. 

대표적인 플래그 두개를 소개하자면 

- /g(global)  
  - g플래그는 첫번째 결과 뿐만 아니라 일치하는 모든 결과를 리턴하는 플래그 입니다.
- /i(insensitive) 
  - i 플래그는 대소문자 구분을 하지 않는 플래그 입니다.

언어, 에디터에 따라 기본적으로 적용되는 경우도 있고 되지 않는 경우도 있습니다. 개발 시 플래그는 각 환경에 맞춰서 확인이 필요 합니다. regex101에서 regex입력칸 우측에서도 확인 할 수 있습니다.



### 모든 문자 찾기

알고 있는 문자를 찾는건 이미 단순한 찾기에서도 사용이 됩니다. RegEx를 사용 하는 것은 특정 형식은 있는데 안에 있는 문자는 모를때 더 유용합니다. 그렇기 때문에 모르는 문자를 찾는 법을 알아야 합니다.

---

lapin

lepre

konijn

coelho

lepus

kaninchen

liebre

---

여기서 l로 시작하는 문자열을 찾고 싶다면 l. 를 입력해봅시다.

> l. 

---

**la**pin

**le**pre

konijn

**le**pus

kaninchen

**li**ebre

---

정확히는 두 글자만을 찾기 때문에 앞에 두 글자만 검색이 되지만, 에디터에서 검색하는 경우에는 l로 시작하는 문자를 알아볼 수 있다. 여기서 .는 아무 문자 하나와 동일합니다.

그렇다면 l로 시작하는 다섯 글자 이상의 단어를 찾고 싶다면 l.... 를 입력하면 됩니다.

> l.... 

---

lap

**lapin**

**lepre**

konijn

**lepus**

kaninchen

**liebr**e

---



#### 요약

- . 는 아무 문자 하나에 해당한다.



### 반복하기

그렇다면 특정 글자수를 찾고 싶을때는 계속 ..... 를 찍어야 할까요?

만약 [Pneumonoultramicroscopicsilicovolcanoconiosis](https://ko.wikipedia.org/wiki/뉴모노울트라마이크로스코픽실리코볼케이노코니오시스) 이런 긴 단어를 특정하고 싶다면 P.................... 이렇게 해야 할까요?

이런 긴 글자도 찾기 위해서는 +와 *이 있습니다. +혹은 \* 앞에 있는 글자를 반복합니다.



> l.\* 

---

Since I was in **la** in 1994..

**lapin**

**lepre**

konijn

---



> l.+

---

Since I was in la in 1994...

**lapin**

**lepre**

konijn

---

위 두 예시를 볼 때 l.\*는 la를 인식하지만 l.+는 la를 인식하지 않습니다. \*는 .에 대응하는 문자가 없어도 되지만, +는 .에 대응하는 문자가 적어도 한개는 되어야 합니다.

예를 들면 ab*는 a도 찾고, ab도 찾고 abb,abbb,abbbb,abbbbb... 도 찾지만, ab+는 a를 찾을 수 없습니다.



\*, + 는 반복이라고는 하는데 얼만큼 반복하는지도 지정하고 싶으실 겁니다. 그렇다면 \*,+ 대신 숫자를 감싼 중괄호를 넣습니다.

> l.{1,3}

---

**lapi**n

**lepr**e

konijn

coelho

**lepu**s

kaninchen

**lieb**re

---

.에 해당하는 문자가 최소 하나, 최대 3개가 있는 문자열을 찾도록 하였습니다.

형태를 살펴보면 {n,m} 이고 n은 최소로 반복해야 하는 숫자, m은 최대로 반복하는 숫자 입니다.

만약에 최소만 지정하고 무한으로 반복한다면 .{n,}처럼 콤마는 찍고 최대 반복에 해당하는 숫자는 적지 않으셔야 합니다.  .{n}으로 쓴다면 n번만 들어간다가 됩니다.

참고로 \*는 {0,}와 같으며, +는 {1,}와 같습니다.



\*, +, {n,m}는 바로 앞에 있는 문자에 대응하는 문자를 반복한다고 하였습니다. 그렇지만 조심해야 할 것이 있습니다.

```html
<b>Rabbit</b> and <b>hamster</b>
```

위와 같은 html태그가 있는데요 b태그로 감싸진 구간을 찾기 위해서 다음과 같은 regex를 사용해보도록 하겠습니다.

`<b>.\*<\/b>`

그렇다면 다음과 같은 결과가 나옵니다.

> **&lt;b&gt;Rabbit&lt;/b&gt; and &lt;b&gt;hamster&lt;/b&gt;**

위와 같이 모든 텍스트가 선택이 됩니다. 이는 \*, +가 탐욕적이라서(greedy) 범위가 되는 최대한의 문자를 잡으려고 하는 속성이 있어서 그렇습니다. 그러면 어떻게 이 탐욕을 바로 잡을 수 있을까요? 바로 뒤에 ?만 붙이면 됩니다.

```
<b>.*?<\/b>
```

> **&lt;b&gt;Rabbit&lt;/b**&gt; and **&lt;b&gt;hamster&lt;/b&gt;**

\*,+ 뒤에 ?를 붙이니 게을러져서(lazy) b태그로 감싸진 곳만 감싸지고 b태그로 감싸지지 않은 'and'는 감싸지지 않습니다.



#### 요약

- \*, +는 바로 앞에 있는 문자를 반복한다 = 바로 앞에 있는 문자가 반복된 문자열을 찾는다
- \*는 앞에 있는 문자가 반복되지 않아도 괜찮다.  
- +는 앞에 있는 문자가 적어도 한개 이상은 있어야 한다
- {n,m} 은 바로 앞에 있는 문자를 최소 n번, 최대 m번 반복한다.
  - 최소 n번만 조건을 지정하려면 {n,}으로 m만 쓰지 않으면 된다
  - 콤마를 적지 않으면 {n} n번만 반복이 된다.
- \*,+,{n,m}은 탐욕스러워서 최대한을 잡지만 뒤에 ?를 붙이면 게을러져서 최소한만 잡는다.



### 단어의 범위

이 글을 읽다 보면은 조금 불편함을 느끼셨을지도 모릅니다.

> l.{4}

---

lap

**lapin**

**lepre**

konijn

**lepus**

kaninchen

**liebr**e

---



l뒤에 네글자 붙은 단어를 찾으려고 했는데 해당 식으로는 liebre처럼 총 5글자가 넘는 글자의 일부도 검출을 하게 됩니다. 원래 의도는 l뒤에 4글자만 있는 것을 추출하고 싶은데 말이죠. 이때 단어의 경계를 지정해 주는 것이 필요합니다.

> \bl.{4}\b

백슬래시 + b 를 활용하여 단어의 경계를 지정할 수 있습니다.

이렇게 \b로 단어의 경계를 찾아서 검색하면 정확히 l과 임의의 글자 4개로 구성된 단어를 정확히 찾을 수 있습니다.

좀더 더 예를 들자면 

> private val value: String = "Festival"

라는 문자열에서 val만을 찾으려고 합니다. val로만 찾는다면 value, "Festival"에서도 val을 찾게 됩니다

>  val -> private **val** **val**ue: String = "Festi**val**"

하지만 val을 \b로 감싼다면 

> \bval\b -> private **val** value: String = "Festival"

val 만 찾을 수 있습니다.



혹시 단어 속에 val이 들어있는 것을 찾고 싶다면 val 주변에 \B로 감싸줍니다.

---

evaluation

evolution

festival

---



---

> \Bval\B

---

e**val**uation

evolution

festival

---

\B는 단어 경계가 아닌 것을 검출하는 기능을 합니다. 단어 경계라는게 공백, 줄바꿈, 문자열 끝을 의미하는데, festival 단어 뒤에는 줄바꿈, 공백, 문자열 끝 이 존재하기 때문에 \B가 검출을 하지 못합니다.

그렇다면 이를 바탕으로 응용할 수 있는게

val로 시작하는 단어를 찾으려면 \bval\B, 끝나는 단어를 찾으려면 \Bval\b 를 사용하면 됩니다.

단어는 주로 알파벳이나 숫자로 시작하는 문자열을 가리킵니다. 알파벳이나 숫자가 아닌걸로 구성된 문자열도 \b로 찾을 수 있을까요?

> |\b@@@\b -> @@@ abc @@@ abc|

찾을 수 없습니다. 반대로 \B라면 어떨까요?

> \B@@@\B -> **@@@** abc **@@@** abc

\B는 알파벳이나 숫자가 아닌 다른걸로 된 문자열의 경계(공백 등)를 가리키기도 합니다.

문자열 속에 있는 특수 문자로 된 문자열을 찾으려면 \b를 써볼까요?

> \b@\b -> master**@**master.com

@를 찾을 수 있습니다.



또한 전체 문자열을 기준으로 할 때

^는 문자열의 시작이고, $는 문자열의 끝을 가리킵니다.

평소에 텍스트 중간에 있는 단어들을 찾을때는 별로 쓰이지는 않겠지만, xml파일에서 파일 헤더에 들어가는 &lt;?xml version="1.0"&gt; 같은걸 찾는다던지, html끝에 들어가는 &lt;/html&gt;를 찾아야 할 때 사용 할 수 있습니다.



#### 요약

- \b옆에 있는게 단어라면 \b는 공백, 줄바꿈, 문자열 끝, 알파벳과 숫자가 아닌 문자가 있는지 찾기
- \b옆에 있는게 단어가 아니라면 \b는 공백, 줄바꿈, 문자열 끝, 알파벳과 숫자인 문자 찾기
- \B옆에 있는게 단어라면 \B는 공백, 줄바꿈, 문자열 끝, 알파벳과 숫자인 문자가 있는지 찾기
- \B옆에 있는게 단어가 아니라면 \B는 공백, 줄바꿈, 문자열 끝, 알파벳과 숫자가 아닌 문자 찾기
- \b와 \B는 서로 반대의 기능을함



### 문자 집단 찾기

지금까지 모든 문자를 가리키는 .으로 검색을 했습니다. 그리고 \b를 언급하면서 알파벳과 숫자가 아닌 문자, 알파벳과 숫자 등을 언급했는데요, .대신 해당 글자에 알파벳만 들어가거나 숫자가 들어갈때는 어떻게 해야 할까요?

아래 식을 참고해봅시다

> [abcd]

---

l**a**pin

lepre

lepus

lie**b**re

**ca**t

---

특정 문자가 a or b or c or d 인 것만 검출을 합니다.

특정 글자 중 하나를 찾으려면 대괄호에 특정 글자를 넣으면 됩니다.

예를들어 숫자들을 찾으려면 [0123456789]를 입력하면 되고 알파벳 소문자를 찾으려면 [abcdefghijklmnopqrstuvwxyz] 를 넣으면 됩니다.

이러면 일일이 a to z 다 넣으려면 불편하죠? 그래서 축약 해서 아래와 같이 하면 됩니다.

> [a-z] : 소문자 알파벳 a부터 z까지
>
> [A-Z] : 대문자 알파벳
>
> [0-9] : 숫자
>
> [a-f] : 소문자 a부터 f까지

뿐만 아니라 대괄호 안에 여러 문자를 넣었듯이 위의 식도 대괄호 안에서 여러개 조합이 가능합니다.

> [a-zA-Z0-9] : 모든 알파벳과 숫자

특정 문자를 제외하고 싶다면 ^를 사용하도록 합니다

> [^0-9] : 숫자를 제외하고 찾기



> \[a-z]\[a-z]\[a-z]

---

**abc**

a12

---



> \[a-z]\[^a-z]\[^a-z]

---

abc

**a12**

---



만약에 더 줄이고 싶다면

> \d : 0-9까지 숫자
>
> \D : 숫자가 아닌 문자
>
> \w : 대소문자, 숫자, 언더바(_)
>
> \W : 대소문자, 숫자, 언더바가 아닌 모든 문자



를 사용하시면 됩니다.



#### 요약

- 대괄호 안에 문자들을 넣으면 해당 문자들 중 하나가 있는 것을 검출
- a-z, A-Z, 0-9 등 범위를 대괄호 안에 넣을 수 있음
- \d, \w로 축약할 수 있음



### 메타 문자

메타문자 라는 것은 특정 문자가 Regular Expression안에서 다른 기능을 하는 것을 말합니다. 예를들어 .는 .를 찾는게 아닌 전체 문자 중 하나를 찾는 기능입니다. 대괄호, 중괄호 \*, + 도 메타문자의 기능을 하죠. 메타문자로 사용된 문자를 그대로 찾고 싶으면 \\ 를 붙이면 됩니다.



> .

---

**google.com**

---



> \\.

---

google**.**com

---



괄호, 중괄호, 대괄호, *, + 등 특수한 기능을 하는 문자들도 동일하게 \\ 를 붙이면 문자 그대로 검출이 가능합니다. 물론 \\ 도 \\\\ 로 찾으면 됩니다.



코드 작성하면서 \\n \\t 같은 문자를 많이 쓰고 보셨을 겁니다. 이런 메타문자를 Regular Expression에서도 사용이 가능합니다. \\n \\t 같은 것은 공백 문자인데요 주요 공백 문자는 아래와 같습니다.



| 메타문자 |    의미     |
| -------- | :---------: |
| `\n`     |   줄바꿈    |
| `\r`     | 캐리지 리턴 |
| `\t`     |     탭      |



그리고 위에서 언급한 특정 문자중 하나를 검출하는 것도 \\ 를 이용하여 활용이 가능합니다.

| 메타문자 |             의미              |
| -------- | :---------------------------: |
| `\s`     |        모든 공백 문자         |
| `\S`     |  공백 문자가 아닌 모든 문자   |
| `\d`     |           모든 숫자           |
| `\D`     |     숫자가 아닌 모든 문자     |
| `\w`     |   모든 알파벳, 숫자, 언더바   |
| `\W`     | \\w에 해당하지 않는 모든 문자 |

잘 보시면 메타문자 뒤에 알파벳이 대문자가 되면 소문자와 의미가 반대가 됩니다. \\b, \\B 도 마찬가지입니다. 메타 문자를 활용하면 더 간편하게 Regular Expression을 사용하실 수 있습니다.



### 하위표현식

아래와 같은 문자열이 있다고 가정해 봅시다

```
\t\t\t\t\tclass TestClass {
\t\t\t\t\t\tint value = 0
\t\t\t\t\t}
```

여기서 \t를 찾으려면 어떻게 해야 할까요?

> \\\\t

로 찾으면 되겠죠? 그러면 \\t를 여러개 찾으려면 어떻게 해야할까요?

> \\\\t+

이렇게 할까요? 그렇다면 \\t를 여러개 찾을 수 없습니다. 왜냐하면 이건 \\t, \\tt, \\ttt, \\tttt.... 를 찾는 패턴이기 때문이죠. +, *, {} 같은건 바로 앞에 있는 문자만 해당되기 때문입니다. 그러면 해당 패턴을 제대로 찾기 위해서는 어떻게 해야 할까요? 바로 괄호로 묶으면 됩니다.

> (\\\\t)+

---

**\t\t\t\t\t**class TestClass {
**\t\t\t\t\t\t**int value = 0
**\t\t\t\t\t**}

---

이렇게 하면 \\t 문자열이 여러개 있는 패턴을 금방 찾을 수 있습니다.



또한 다른 언어들 처럼 중첩해서 사용할 수 있습니다.

예를 들어 이런 형식의 날짜를 검출한다고 합시다.

`1972.11.21`

> \d{1,4}\\.\d{1,2}\\.\d{1,2}

이렇게 하면 당장에 이 양식은 검색이 될겁니다. 하지만 9999.99.99 같은 날짜에 맞지 않는 양식도 검색이 되겠죠

월과 일을 손대면 이렇게 됩니다.

> \\d{1,4}\\.(([0,1]\d)|(\d))\\.(([0-3]\\d)|(\\d))

여기서 |는 양 옆의 조건 중 하나만 일치해도 검출이 되는 or 조건 입니다.

or조건이나 반복문을 중첩된 괄호 안에 사용 가능합니다.



#### 요약

- 다른 언어들 처럼 괄호로 패턴을 묶을 수 있다.
- 다른 언어들 처럼 or조건, 반복을 중첩된 괄호에 사용가능 하다.



### 그룹화

괄호로 묶게 되면 일종의 집합처럼 묶입니다. 제일 상위의 괄호를 기준으로 그룹을 사용할 수 있습니다. 

예를 들어 html태그가 있다고 칩시다

```
<h1>Title1</h1>
<h1>Title1</h2>
```

올바른 html이라면 시작 태그와 끝의 태그에 있는 코드가 동일해야 합니다. 첫째줄은 동일한데 둘째줄은 h2로 달라져 있습니다. 지금까지 배웠던 Regex로 검출식을 써봅시다.

> &lt;h\\d&gt;.*&lt;\h/\\d&gt;

이렇게 작성을 하면 두 줄 모두 검출이 됩니다.

이럴 때 h1에 해당하는 부분을 괄호로 묶어 줍시다.

> &lt;(h\\d)&gt;.*&lt;\/\1&gt;

이렇게 하면 첫번째 줄만 검출이 됩니다.

백슬래시 뒤에 있는 숫자는 첫번째 그룹이라는 의미 입니다. 제일 바깥쪽에 있는 괄호를 기준으로 순서가 결정이 됩니다. 

숫자로 지정하기 헷갈리신다면 그룹에 이름을 넣을 수 있습니다.

> &lt;(?'tag'h\\d)&gt;.*&lt;\/(?P=tag)&gt;

이런식으로 ?'name'으로 이름을 주고 (?P=name) 로 그룹 검출을 할 수 있습니다. 이름을 주는 방식은 제일 바깥에 있는 괄호 말고도 안쪽 괄호에도 그룹을 줄 수 있습니다.

그룹을 찾을 때 주의해야 할 것이 반복문의 경우 제일 마지막 패턴만을 가져옵니다.

예를들어

``abc.123`` 을 검출 할 때

> (\\w)+\.(\\d)+

식을 사용한다고 가정합니다. abc를 모두 찾고 싶지만 그룹 1을 찾으려면 c만이 검출 됩니다. 그룹2를 찾으려 하면 abc중에 나오는게 아니라 \\d의 마지막 패턴인 3만이 나옵니다. 그룹3은 없습니다. 

> ((\\w)+).((\\d)+) 

이런 식으로 반복문을 한번 더 감싸면 그룹1은 abc, 그룹2는 123이 나오게 됩니다.

아니면 식이 너무 복잡해질거 같으면 해당 그룹은 ?:을 앞에 붙여서 참조를 하지 않도록 하는 방법도 있습니다.

> (?:\\w)+\.(?:\\d)+

이렇게 하면 어떠한 그룹도 검출되지 않습니다.



이렇게 그룹을 해서 참조하는 주요한 이유는 바로 특정 패턴을 replace하는 것에 있습니다.

replace할 때에도 regex를 활용할 수 있습니다.

예를 들면 언더바로 된 변수명을 camelBack형태로 바꿀때 사용할 수 있습니다.

```
lovely_rabbit
```

을 camelBack으로 바꿔봅시다. 

_를 좌우로 해서 두 단어를 그룹화 합시다

> ([a-z]+)_([a-z]+)

그러면 lovely는 1번그룹, rabbit은 2번 그룹이 됩니다.

replace로 붙여 넣을때는 그룹 앞에 $를 붙입니다. ?'name'로 이름으로 그룹을 지정했던것도 $를 붙이면 됩니다. 한번 replace해봅시다.

>$1$2 -> lovelyrabbit

_는 사라졌지만 camelback은 아닙니다. r이 대문자가 되어야 하는데요,

([a-z]+)_(r)([a-z]+)를 해서 $1R$3으로 해도 되긴 하지만, 실제로 사용해야 한다면, 바꿔야 할게 저것 뿐일까요? 여기서 메타문자가 등장을 합니다.

> $1\u$2 -> lovelyRabbit

\\u 라는 메타문자를 $2에 붙여서 rabbit를 Rabbit으로 변경 하였습니다.

\\u는 바로 뒤에 오는 문자를 대문자로 바꿔주는 메타문자 입니다. 반대로 \\l은 바로 뒤에 오는 문자를 소문자로 바꿔줍니다.

다른 예를 들어볼까요? 방금 작업했던 언더바가 있는 변수명을 언더바를 없애고 전부 대문자로 전부 변환해보려고 합니다.

하나하나 문자를 분할해서 \u를 하려면 너무 귀찮습니다. 그렇다면 범위를 지정해서 한번에 바꿔 봅시다. 

> \\U$1$2 -> LOVELYRABBIT

\\U는 뒤에 있는 모든 글자를 대문자로 바꿔줍니다. \\L은 뒤에 있는 모든 글자를 소문자로 바꿔줍니다. 혹시나 앞에 있는 lovely까지 바꾸고 싶다면 어떻게 해야 할까요?

> \\U$1\\E$2 -> LOVELYrabbit

\\E 메타문자를 가지고 \\U나 \\L에서 변환하려는 범위를 정할 수 있습니다.

이처럼 그룹화를 하고 이를 참조하면서 메타문자를 활용해 특정 텍스트를 치환할 수 있습니다.

| 메타문자 |                 의미                  |
| -------- | :-----------------------------------: |
| `\U`     | 뒤에 있는 모든 글자를 대문자로 만든다 |
| `\L`     | 뒤에 있는 모든 글자를 소문자로 만든다 |
| `\u`     |  뒤에 있는 한 글자를 대문자로 만든다  |
| `\l`     |  뒤에 있는 한 글자를 소문자로 만든다  |
| `\E`     |   \\U, \\L 이 끝나는 지점을 정한다    |



#### 요약

- 제일 바깥에 괄호가 된 것을 그룹으로 지정할 수 있다
- 기본값은 왼쪽부터 1번이며 문자열로 이름을 지정할 수 있다
- 반복문은 그룹화를 활용하기 어렵다.
- 그룹화를 응용하여 replace를 사용 가능하다.



### 탐색

특정 텍스트 기준으로 찾고 싶은데 지금까지 알아본 것으로만 사용하면 특정 텍스트도 포함하여 찾게 됩니다.

예를 들어 이메일인 `abc@abc.com` 인 경우 @를 기준으로 앞에는 아이디, 뒤에는 도메인인데 아이디를 찾으려면 .+@ 일테고, 도메인을 찾으려면 @.+ 일겁니다. 

아이디와 도메인만 검출하고 싶다면 어떻게 해야 할까요?

먼저 아이디 부터 찾아 봅시다

> .+(?=@) -> **abc**@abc.com



?=문자 를 쓰게 되면 문자를 기준으로 앞으로 찾되 해당 문자는 검출하지 않습니다. 이렇게 앞으로 찾는 것을 전방탐색(lookahead)라고 합니다.



그러면 뒤에 도메인 부분을 찾아 볼까요?

> (?&lt;=).+ -> abc@**abc.com**

?&lt;=문자 를 쓰게 되면 문자를 기준으로 뒤로 찾되 해당 문자는 검출하지 않습니다. 이렇게 뒤로 찾는 것을 후방탐색(lookbehind)라고 합니다.



그렇다면 @가 없는 것을 찾으려면 어떻게 해야 할까요?

@가 없는 전방 탐색을 하려면

>(?!@)

@가 없는 후방 탐색을 하려면

> (?<!@)

를 사용 하면 됩니다.



탐색을 할 때 주의해야 할 것이 앞 뒤에 있는 다른 regex에 따라서 해당 문자가 검출 될 수 있습니다. 그러므로 필요한 경계 \\b, \\B를 활용하여 찾을 것을 권장 합니다.

### 조건

Regex에서도 조건을 달 수 있습니다. 특정 regex 패턴이 존재 한다면 괄호 안에 있는 패턴을 실행시키는 방식 입니다.

코틀린 언어에서는 클래스 전역변수를 초기화 하지 않고 필요한 시점 예를 들면 액티비티 생명 주기에 따라서 나중에 정의해도 되도록 하는 lateinit이라고 하는 예약어가 있습니다.

lateinit는 var(값이 변할 수 있는 변수)만 사용가능하며 val(값이 변하지 않는 변수)는 사용이 안됩니다.

lateinit라는 예약어를 붙이지 않고 초기값을 넣지 않거나 val 을 사용하거나 혹은 lateinit를 붙이고 초기값을 넣는다면 에러가 생깁니다. 그러면 lateinit가 올바르게 사용 되었는지 검출해 봅시다

```
^(lateinit\s+)?(?(1)var|va[rl])\s+\w+(?(1)\s*|\s*=\s*\w+)$
```

---

**lateinit var value1**
**val value2 = 100**
val value3
**var value4 = 200**
lateinit val value5
lateinit var value6 = 0

---

이렇게 해당 식을 사용하게 되면 올바르게 사용된 lateinit를 검출할 수 있습니다.

여기서 사용된 조건식의 형태는 다음과 같은데요

> ?(조건/검출)(조건에맞으면)|(조건에안맞으면)

조건에는 전방탐색, 후방탐색이 들어가기도 하고, 특정 패턴이 들어가기도 하며 그룹이 들어가기도 합니다.

</details>


## Regular Expression 사용 사례

### 일상에서의 사례

#### 이메일 검출

이메일의 경우 보통은 알파벳이 제일 먼저 오며 숫자나 언더바, 마침표 등은 중간에 오는 경향이 있습니다. 그리고 @로 아이디와 도메인이 구별되며 도메인은 google.com과 같이 중간에 마침표가 들어갑니다. \\w는 언더바도 포함하므로 도메인 앞에 글자는 알파벳과 숫자로 한정 시킵니다. 

> \[a-zA-Z\](\[-.\]?\[\w\])\*@\[a-zA-Z\d\](\[-.\]?\[\\w\])\*.\w+



#### 주민등록번호 검출

주민등록번호도 패턴화 할 수 있습니다. 연도2자리, 월2자리, 날짜2자리 그리고 뒤에는 성별1자리 나머지 6자리 입니다. (지역 구분 등은 지금은 없다고 하니 따로 고려하지는 않겠습니다.)

> \\d{2}((0\\d)|1[0-2])(([0-2]\\d)|3[01])-[1-4]\d{6}



#### 전화번호 검출

전화번호도 패턴화 할 수 있습니다. 일단 국내 한정으로

> (0\d{1,2}-)?\d{3,4}-\d{4}

정도로 검출이 되며, 국제번호는 앞에 국가번호를 붙이는 패턴을 더 붙이면 됩니다. 



### 개발 중 사례 (Android Studio, Kotlin 기준)

제가 Regex를 공부해보고 작성하거나 활용해본 사례들을 기록해보도록 하겠습니다. Android Studio에서 Kotlin언어 기준으로 작성하였기 때문에 다른 언어에서 혹시나 활용하신게 있으시면 댓글로 알려주시기를 부탁 드립니다.

#### 클래스 찾기

완벽하게 클래스를 찾으려면 자바 컴파일러에 대해 이해를 해야 할 것 같습니다. 왜냐하면 생각보다 패턴이 복잡하더라고요. class A 를 선언할때에도

```kotlin
class NormalClass(@SerializedName("value") val value1,
                 val value2: String = "InitialValue" + " is " + "nothing", val value3 = ((1+2) * (3-6))
```

수식 등을 쓰다보면(물론 이렇게 잘 쓰시지는 않으시겠지만) 예상했던 패턴과 다른 패턴들이 나올 수 있곤 합니다. 어떨땐 괄호가 헷갈리기도 하고요.

제가 최대로 찾아본 클래스 찾는 regex문 입니다.

```
(data|open|enum)?[\s]*class[\s]*[a-zA-Z][\a-zA-Z0-9_]*[\s]*\([\s]*(@[a-zA-Z][a-zA-Z0-9]*[\s]*\(\".*?\"\))?[\s]*va[rl][\s]+[a-zA-Z][a-zA-Z0-9]*[\s]*:[\s]*[a-zA-Z][a-zA-Z0-9<>.]*[?]?[\s]*(=[\s]*((\".*?\")|true|false|[a-zA-Z][a-zA-Z0-9]*|(([\d]*(\.[\d]*)?([f|l]?)))))?([\s]*,[\s]*(@[a-zA-Z][a-zA-Z0-9]*[\s]*\(\".*?\"\))?[\s]*va[rl][\s]+[a-zA-Z][a-zA-Z0-9]*[\s]*:[\s]*[a-zA-Z][a-zA-Z0-9<>.]*[?]?[\s]*(=[\s]*((\".*?\")|true|false|[a-zA-Z][a-zA-Z0-9]*|(([\d]*(\.[\d]*)?([f|l]?)))))?)*\)[\s]*(:[\s]*[a-zA-Z][a-zA-Z0-9<>.]*[\s]*\([\s]*((\".*?\")|true|false|[a-zA-Z][a-zA-Z0-9]*|(([\d]*(\.[\d]*)?([f|l]?))))[\s]*(,[\s]*((\".*?\")|true|false|[a-zA-Z][a-zA-Z0-9]*|(([\d]*(\.[\d]*)?([f|l]?))))[\s]*)*\))?
```

이렇게 해도 잘 안되는 클래스들도 있을겁니다. 이렇게 까지 하면 너무너무 복잡하기 때문에 간단하게 찾도록 합시다.

```
class[\s]*(클래스명)[\s]*\(.*\)
```

특정 클래스를 상속받은 클래스 찾는 것은 다음과 같습니다.

```
class[\s]*[a-zA-Z0-9_]+[\s]*(\(.*\))?[\s]*(:[a-zA-Z0-9\s<>,]*(클래스이름)[a-zA-Z0-9\s<>,]*)?
```

kotlin에서는 콜론 뒤에 클래스들을 나열하는 방식이라 클래스 이름이 어디에 있을지 모릅니다. 클래스 이름 반복과 클래스이름 반복 사이에 넣으면 클래스이름을 찾을 수 있게 됩니다.



#### 변수 찾기

변수도 역시 찾을 수 있습니다.

```
va[r|l][\s]+[a-zA-Z][\w]*[\s]*(:[\s]*[a-zA-Z][\w]*)?[\s]*=[\s]*
va[r|l][\s]+(변수명)[\s]*(:[\s]*[a-zA-Z][\w]*)?[\s]*=[\s]*
```

특정 값을 가진 변수를 찾을 수 있습니다.

```
va[r|l][\s]+[a-zA-Z][\w]*[\s]*(:[\s]*[a-zA-Z][\w]*)?[\s]*=[\s]*((\".*?\")|true|false|[a-zA-Z][a-zA-Z0-9]*|(([\d]*(\.[\d]*)?([f|l]?))))
va[r|l][\s]+(변수명)[\s]*(:[\s]*[a-zA-Z][\w]*)?[\s]*=[\s]*(변수값)
```

위에서 설명한 lateinit검출도 있습니다.

lateinit가 없으면 반드시 값을 정해야 하나 lateinit가 있는 var은 값을 처음에 정하지 않아야 합니다.

```
^(lateinit\s+)?(?(1)var|va[rl])\s+\w+(?(1)\s*|\s*=\s*\w+)$
```



#### xml에서 하드코딩 된 값 찾기

```
레이아웃에서 하드코딩된 컬러 찾기
=\s*\"#([0-9a-fA-f]{2})?([0-9a-fA-f]){6}\"
```

```
레이아웃에서 하드코딩 된 dp/sp 찾기
=\s*\"[\d]+[sd]p\"
```



#### 변수 이름 바꾸기

언더바 1개짜리 -> 카멜백

```
([a-z]+[0-9a-z]*)(_)([a-z])([0-9a-z]*) -> $1\u$3$4
```

카멜백 대문자 1개짜리 -> 언더바

```
([a-z]+[0-9a-z]*)([A-Z])([0-9a-z]*) -> $1_\l$2$3
```





## 마치면서

지금까지 Regular Expression 에 대해서 알아 보았습니다. 한 줄에 코드를 다 적고, 공백을 넣으면 깨지고 하면서 막상 다 쓰고 나면 복잡해 보이는 것도 사실입니다. 그치만 자신만의 Regex식을 몇개 구비해 두면 나중에 텍스트를 찾기 하거나 IDE를 쓸 때 그냥 찾기 하는 것 보다 더 쉽고 효율적으로 찾을 수 있을 것 입니다. 그리고 텍스트 처리를 할 때 코드를 좀 더 간결하게 작성하실 수 있게 될 겁니다.



## References

- 벤 포터(2020) 손에 잡히는 10분 정규 표현식(Learning Regular Expressions), 인사이트
- https://regex101.com/
- http://zvon.org/comp/m/regular_expressions.html
- http://gypark.pe.kr/wiki/Perl/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D
- https://ko.wikipedia.org/wiki/%EC%A0%95%EA%B7%9C_%ED%91%9C%ED%98%84%EC%8B%9D